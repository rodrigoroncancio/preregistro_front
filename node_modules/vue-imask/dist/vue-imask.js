(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('imask'), require('vue-demi')) :
  typeof define === 'function' && define.amd ? define(['exports', 'imask', 'vue-demi'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.VueIMask = {}, global.IMask, global.VueDemi));
})(this, (function (exports, IMask, vueDemi) { 'use strict';

  function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

  var IMask__default = /*#__PURE__*/_interopDefault(IMask);

  var props = {
    // common
    mask: undefined,
    prepare: Function,
    prepareChar: Function,
    validate: Function,
    commit: Function,
    overwrite: {
      type: Boolean,
      required: false,
      default: undefined
    },
    eager: {
      required: false,
      default: undefined,
      validator: value => ['append', 'remove'].includes(value) || typeof value === 'boolean'
    },
    skipInvalid: {
      type: Boolean,
      required: false,
      default: undefined
    },
    // pattern
    placeholderChar: String,
    displayChar: String,
    lazy: {
      type: Boolean,
      required: false,
      default: undefined
    },
    definitions: Object,
    blocks: Object,
    // enum
    enum: Array,
    // range
    maxLength: Number,
    from: Number,
    to: Number,
    // date
    pattern: String,
    format: Function,
    parse: Function,
    autofix: {
      required: false,
      default: undefined,
      validator: value => value === 'pad' || typeof value === 'boolean'
    },
    // number
    radix: String,
    thousandsSeparator: String,
    mapToRadix: Array,
    scale: Number,
    normalizeZeros: {
      type: Boolean,
      required: false,
      default: undefined
    },
    padFractionalZeros: {
      type: Boolean,
      required: false,
      default: undefined
    },
    min: [Number, Date],
    max: [Number, Date],
    // dynamic
    dispatch: Function
  };

  function useIMask(props, _temp) {
    let {
      emit,
      onAccept,
      onComplete,
      defaultValue,
      defaultUnmaskedValue,
      defaultTypedValue
    } = _temp === void 0 ? {} : _temp;
    const _props = vueDemi.isRef(props) ? props : vueDemi.ref(props);
    const el = vueDemi.ref();
    const mask = vueDemi.ref();
    const masked = vueDemi.ref('');
    const unmasked = vueDemi.ref('');
    const typed = vueDemi.ref();
    let $el;
    let $lastAcceptedValue = masked.value;
    let $lastAcceptedUnmaskedValue = unmasked.value;
    let $lastAcceptedTypedValue = typed.value;
    function storeLastAcceptedValues() {
      $lastAcceptedTypedValue = typed.value = mask.value.typedValue;
      $lastAcceptedUnmaskedValue = unmasked.value = mask.value.unmaskedValue;
      $lastAcceptedValue = masked.value = mask.value.value;
    }
    function _onAccept(event) {
      storeLastAcceptedValues();
      if (emit) {
        emit('accept', masked.value, event);
        emit('accept:masked', masked.value, event);
        emit('accept:typed', typed.value, event);
        emit('accept:unmasked', unmasked.value, event);
      }
      onAccept == null || onAccept(event);
    }
    function _onComplete(event) {
      if (emit) {
        emit('complete', mask.value.value, event);
        emit('complete:masked', mask.value.value, event);
        emit('complete:typed', mask.value.typedValue, event);
        emit('complete:unmasked', mask.value.unmaskedValue, event);
      }
      onComplete == null || onComplete(event);
    }
    const updateUnmaskedValue = () => {
      if (!mask.value || unmasked.value === undefined) return;
      if ($lastAcceptedUnmaskedValue !== unmasked.value) {
        mask.value.unmaskedValue = unmasked.value;
        if (mask.value.unmaskedValue !== unmasked.value) _onAccept();
      }
      $lastAcceptedUnmaskedValue = undefined;
    };
    vueDemi.watch(unmasked, updateUnmaskedValue);
    const updateMaskedValue = () => {
      if (!mask.value || masked.value === undefined) return;
      if ($lastAcceptedValue !== masked.value) {
        mask.value.value = masked.value;
        if (mask.value.value !== masked.value) _onAccept();
      }
      $lastAcceptedValue = undefined;
    };
    vueDemi.watch(masked, updateMaskedValue);
    const updateTypedValue = () => {
      if (!mask.value || typed.value === undefined) return;
      if ($lastAcceptedTypedValue !== typed.value) {
        mask.value.typedValue = typed.value;
        if (!mask.value.masked.typedValueEquals(typed.value)) _onAccept();
      }
      $lastAcceptedTypedValue = undefined;
    };
    vueDemi.watch(typed, updateTypedValue);
    function _initMask() {
      $el = el.value;
      const $props = _props.value;
      if (!$el || !($props != null && $props.mask)) return;
      mask.value = IMask__default.default($el, $props);
      if (defaultValue !== undefined) masked.value = defaultValue;
      if (defaultUnmaskedValue !== undefined) unmasked.value = defaultUnmaskedValue;
      if (defaultTypedValue !== undefined) typed.value = defaultTypedValue;
      updateUnmaskedValue();
      updateMaskedValue();
      updateTypedValue();
      storeLastAcceptedValues();
      mask.value.on('accept', _onAccept).on('complete', _onComplete);
    }
    function _destroyMask() {
      var _mask$value;
      (_mask$value = mask.value) == null || _mask$value.destroy();
      mask.value = undefined;
    }
    vueDemi.onMounted(_initMask);
    vueDemi.onUnmounted(_destroyMask);
    vueDemi.watch([el, _props], () => {
      const $newEl = el.value;
      const $props = _props.value;
      if (!($props != null && $props.mask) || $newEl !== $el) _destroyMask();
      if ($newEl) {
        if (!mask.value) {
          _initMask();
        } else {
          mask.value.updateOptions($props);
        }
      }
    });
    return {
      el,
      mask: vueDemi.readonly(mask),
      masked,
      unmasked,
      typed
    };
  }

  function extractOptionsFromProps(props, exclude) {
    props = {
      ...props
    };

    // keep only defined props
    Object.keys(props).forEach(prop => {
      if (props[prop] === undefined || exclude.includes(prop)) delete props[prop];
    });
    return props;
  }

  // order does matter = priority
  const VALUE_PROPS = ['typed', 'unmasked', 'value', 'modelValue'];
  var Component3 = vueDemi.defineComponent({
    name: 'imask-input',
    inheritAttrs: false,
    props: {
      // plugin
      modelValue: String,
      value: String,
      unmasked: String,
      typed: {
        validator: () => true
      },
      ...props
    },
    emits: ['update:modelValue', 'update:masked', 'update:value', 'update:unmasked', 'update:typed', 'accept', 'accept:value', 'accept:masked', 'accept:unmasked', 'accept:typed', 'complete', 'complete:value', 'complete:masked', 'complete:unmasked', 'complete:typed'],
    setup(props, _ref) {
      let {
        attrs,
        emit
      } = _ref;
      const {
        el,
        mask,
        masked,
        unmasked,
        typed
      } = useIMask(extractOptionsFromProps(props, VALUE_PROPS), {
        emit,
        onAccept: event => {
          // emit more events
          const v = masked.value;
          emit('accept:value', v, event);
          emit('update:value', v, event);
          emit('update:masked', v, event);
          emit('update:modelValue', v, event);
          emit('update:unmasked', unmasked.value, event);
          emit('update:typed', typed.value, event);
        },
        onComplete: event => {
          emit('complete:value', masked.value, event);
        }
      });
      const pvalue = vueDemi.toRef(props, 'value');
      const pmodelValue = vueDemi.toRef(props, 'modelValue');
      const punmasked = vueDemi.toRef(props, 'unmasked');
      const ptyped = vueDemi.toRef(props, 'typed');
      masked.value = pmodelValue.value || pvalue.value || '';
      unmasked.value = punmasked.value || '';
      typed.value = ptyped.value;
      vueDemi.watch(pvalue, v => masked.value = v);
      vueDemi.watch(pmodelValue, v => masked.value = v);
      vueDemi.watch(punmasked, v => unmasked.value = v);
      vueDemi.watch(ptyped, v => typed.value = v);
      return () => {
        // TODO type?
        const data = {
          ...attrs,
          value: props.value != null ? props.value : props.modelValue != null ? props.modelValue : mask.value ? mask.value.displayValue : '',
          ref: el
        };
        if (!props.mask) {
          data.onInput = event => {
            emit('update:modelValue', event.target.value);
            emit('update:value', event.target.value);
          };
        }
        return vueDemi.h('input', data);
      };
    }
  });

  var Component2 = vueDemi.Vue2 == null ? void 0 : vueDemi.Vue2.extend({
    name: 'imask-input',
    data() {
      return {};
    },
    render(createElement) {
      const data = {
        domProps: {
          value: this.maskRef ? this.maskRef.value : this.value
        },
        on: {
          ...this.$listeners
        }
      };

      // if there is no mask use default input event
      if (!this.$props.mask) {
        data.on.input = event => this.$emit('input', event.target.value);
      } else {
        delete data.on.input;
      }
      return createElement('input', data);
    },
    mounted() {
      if (!this.$props.mask) return;
      this._initMask();
    },
    destroyed() {
      this._destroyMask();
    },
    computed: {
      maskOptions() {
        return extractOptionsFromProps(this.$props, ['value', 'unmask']);
      }
    },
    watch: {
      '$props': {
        handler(props) {
          const maskOptions = this.maskOptions;
          if (maskOptions.mask) {
            if (this.maskRef) {
              this.maskRef.updateOptions(maskOptions);
              if ('value' in props) this._updateValue();
            } else {
              this._initMask(maskOptions);
              if (props.value !== this._maskValue()) this._onAccept();
            }
          } else {
            this._destroyMask();
            if ('value' in props) this.$el.value = props.value;
          }
        },
        deep: true
      }
    },
    methods: {
      _maskValue() {
        var _this$maskRef, _this$maskRef2, _this$maskRef3;
        if (this.unmask === 'typed') return (_this$maskRef = this.maskRef) == null ? void 0 : _this$maskRef.typedValue;
        if (this.unmask) return (_this$maskRef2 = this.maskRef) == null ? void 0 : _this$maskRef2.unmaskedValue;
        return (_this$maskRef3 = this.maskRef) == null ? void 0 : _this$maskRef3.value;
      },
      _updateValue() {
        if (!this.maskRef) return;
        const value = this.value == null && this.unmask !== 'typed' ? '' : this.value;
        if (this.unmask === 'typed') this.maskRef.typedValue = value;else if (this.unmask) this.maskRef.unmaskedValue = value;else this.maskRef.value = value;
      },
      _onAccept() {
        const val = this._maskValue();
        this.$emit('input', val);
        this.$emit('accept', val);
      },
      _onComplete() {
        this.$emit('complete', this._maskValue());
      },
      _initMask(maskOptions) {
        if (!maskOptions) maskOptions = this.maskOptions;
        this.maskRef = IMask__default.default(this.$el, maskOptions).on('accept', this._onAccept.bind(this)).on('complete', this._onComplete.bind(this));
        this._updateValue();
      },
      _destroyMask() {
        if (this.maskRef) {
          this.maskRef.destroy();
          delete this.maskRef;
        }
      }
    },
    props: {
      value: {},
      unmask: {
        validator: value => value === 'typed' || typeof value === 'boolean'
      },
      ...props
    }
  });

  var component = vueDemi.isVue3 ? Component3 : Component2;

  var directive = {
    name: 'imask',
    [vueDemi.isVue3 ? 'beforeMount' : 'bind']: (el, _ref) => {
      let {
        value: options
      } = _ref;
      if (!options) return;
      initMask(el, options);
    },
    [vueDemi.isVue3 ? 'updated' : 'update']: (el, _ref2) => {
      let {
        value: options
      } = _ref2;
      if (options) {
        if (el.maskRef) {
          el.maskRef.updateOptions(options);
          if (el.value !== el.maskRef.value) el.maskRef._onChange();
        } else initMask(el, options);
      } else {
        destroyMask(el);
      }
    },
    [vueDemi.isVue3 ? 'unmounted' : 'unbind']: el => {
      destroyMask(el);
    }
  };
  function fireEvent(el, eventName, data) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(eventName, true, true, data);
    el.dispatchEvent(e);
  }
  function initMask(el, opts) {
    el.maskRef = IMask__default.default(el, opts).on('accept', () => fireEvent(el, 'accept', el.maskRef)).on('complete', () => fireEvent(el, 'complete', el.maskRef));
  }
  function destroyMask(el) {
    if (el.maskRef) {
      el.maskRef.destroy();
      delete el.maskRef;
    }
  }

  Object.defineProperty(exports, "IMask", {
    enumerable: true,
    get: function () { return IMask__default.default; }
  });
  exports.IMaskComponent = component;
  exports.IMaskDirective = directive;
  exports.IMaskProps = props;
  exports.useIMask = useIMask;

}));
//# sourceMappingURL=vue-imask.js.map

import { type DeepReadonly, type Ref } from 'vue-demi';
import { type FactoryOpts, type InputMaskElement, type InputMask } from 'imask';
export type ComposableEmitEventBase = 'accept' | 'complete';
export type ComposableEmitEvent = ComposableEmitEventBase | `${ComposableEmitEventBase}:masked` | `${ComposableEmitEventBase}:typed` | `${ComposableEmitEventBase}:unmasked`;
export type ComposableEmitValue<E extends ComposableEmitEvent, Opts extends FactoryOpts> = E extends ComposableEmitEventBase | `${ComposableEmitEventBase}:masked` ? InputMask<Opts>['value'] : E extends `${ComposableEmitEventBase}:unmasked` ? InputMask<Opts>['unmaskedValue'] : E extends `${ComposableEmitEventBase}:typed` ? InputMask<Opts>['typedValue'] : never;
export type ComposableParams<Opts extends FactoryOpts> = {
    emit?: <E extends ComposableEmitEvent>(eventName: E, value: ComposableEmitValue<E, Opts>, e?: InputEvent) => void;
    onAccept?: (e?: InputEvent) => void;
    onComplete?: (e?: InputEvent) => void;
    defaultValue?: InputMask<Opts>['value'];
    defaultUnmaskedValue?: InputMask<Opts>['unmaskedValue'];
    defaultTypedValue?: InputMask<Opts>['typedValue'];
};
export default function useIMask<MaskElement extends InputMaskElement, Opts extends FactoryOpts>(props: Opts | Ref<Opts>, { emit, onAccept, onComplete, defaultValue, defaultUnmaskedValue, defaultTypedValue, }?: ComposableParams<Opts>): {
    el: Ref<MaskElement | undefined>;
    mask: DeepReadonly<Ref<InputMask<Opts> | undefined>>;
    masked: Ref<InputMask<Opts>['value']>;
    unmasked: Ref<InputMask<Opts>['unmaskedValue']>;
    typed: Ref<InputMask<Opts>['typedValue']>;
};
//# sourceMappingURL=composable.d.ts.map
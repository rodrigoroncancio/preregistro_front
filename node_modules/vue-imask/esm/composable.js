import { isRef, ref, watch, onMounted, onUnmounted, readonly } from 'vue-demi';
import IMask from 'imask/esm/imask';

function useIMask(props, _temp) {
  let {
    emit,
    onAccept,
    onComplete,
    defaultValue,
    defaultUnmaskedValue,
    defaultTypedValue
  } = _temp === void 0 ? {} : _temp;
  const _props = isRef(props) ? props : ref(props);
  const el = ref();
  const mask = ref();
  const masked = ref('');
  const unmasked = ref('');
  const typed = ref();
  let $el;
  let $lastAcceptedValue = masked.value;
  let $lastAcceptedUnmaskedValue = unmasked.value;
  let $lastAcceptedTypedValue = typed.value;
  function storeLastAcceptedValues() {
    $lastAcceptedTypedValue = typed.value = mask.value.typedValue;
    $lastAcceptedUnmaskedValue = unmasked.value = mask.value.unmaskedValue;
    $lastAcceptedValue = masked.value = mask.value.value;
  }
  function _onAccept(event) {
    storeLastAcceptedValues();
    if (emit) {
      emit('accept', masked.value, event);
      emit('accept:masked', masked.value, event);
      emit('accept:typed', typed.value, event);
      emit('accept:unmasked', unmasked.value, event);
    }
    onAccept == null || onAccept(event);
  }
  function _onComplete(event) {
    if (emit) {
      emit('complete', mask.value.value, event);
      emit('complete:masked', mask.value.value, event);
      emit('complete:typed', mask.value.typedValue, event);
      emit('complete:unmasked', mask.value.unmaskedValue, event);
    }
    onComplete == null || onComplete(event);
  }
  const updateUnmaskedValue = () => {
    if (!mask.value || unmasked.value === undefined) return;
    if ($lastAcceptedUnmaskedValue !== unmasked.value) {
      mask.value.unmaskedValue = unmasked.value;
      if (mask.value.unmaskedValue !== unmasked.value) _onAccept();
    }
    $lastAcceptedUnmaskedValue = undefined;
  };
  watch(unmasked, updateUnmaskedValue);
  const updateMaskedValue = () => {
    if (!mask.value || masked.value === undefined) return;
    if ($lastAcceptedValue !== masked.value) {
      mask.value.value = masked.value;
      if (mask.value.value !== masked.value) _onAccept();
    }
    $lastAcceptedValue = undefined;
  };
  watch(masked, updateMaskedValue);
  const updateTypedValue = () => {
    if (!mask.value || typed.value === undefined) return;
    if ($lastAcceptedTypedValue !== typed.value) {
      mask.value.typedValue = typed.value;
      if (!mask.value.masked.typedValueEquals(typed.value)) _onAccept();
    }
    $lastAcceptedTypedValue = undefined;
  };
  watch(typed, updateTypedValue);
  function _initMask() {
    $el = el.value;
    const $props = _props.value;
    if (!$el || !($props != null && $props.mask)) return;
    mask.value = IMask($el, $props);
    if (defaultValue !== undefined) masked.value = defaultValue;
    if (defaultUnmaskedValue !== undefined) unmasked.value = defaultUnmaskedValue;
    if (defaultTypedValue !== undefined) typed.value = defaultTypedValue;
    updateUnmaskedValue();
    updateMaskedValue();
    updateTypedValue();
    storeLastAcceptedValues();
    mask.value.on('accept', _onAccept).on('complete', _onComplete);
  }
  function _destroyMask() {
    var _mask$value;
    (_mask$value = mask.value) == null || _mask$value.destroy();
    mask.value = undefined;
  }
  onMounted(_initMask);
  onUnmounted(_destroyMask);
  watch([el, _props], () => {
    const $newEl = el.value;
    const $props = _props.value;
    if (!($props != null && $props.mask) || $newEl !== $el) _destroyMask();
    if ($newEl) {
      if (!mask.value) {
        _initMask();
      } else {
        mask.value.updateOptions($props);
      }
    }
  });
  return {
    el,
    mask: readonly(mask),
    masked,
    unmasked,
    typed
  };
}

export { useIMask as default };
